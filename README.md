# Welcome to Pathfinding Visualizer!

I built this Pathfinding Visualizer because I was amazed at how cool it was to create an application that could effectively "visualize" each individual step in an algorithm, and because it was so interesting to understand how each of these different pathfinding algorithms actually search for the end node.

Hope you enjoy it! - [Click here for Pathfinding Visualizer!](https://natedddd.github.io/Path_Finder_Animation/)

<br>

# What this Application Has:

## Algorithms

- **Dijkstra** - Guarantees the shortest path in a breadth-first approach
- **Bi-directional Dijkstra** - Similar the Dijkstra, except now the search starts from *both* the Start and Finish nodes. Guarantees the shortest path with less search time
- **A\* Search** - Uses heuristics to guarantee the shortest path; visits a lot less nodes than Dijkstra
- **Greedy Best-first Search** - A more heusitic-heavy search similar to A*; does not guarantee the shorest path
- **Recursive Search** - A blind search algorithm that exhaustively searchest down one path until there are no unvisited nodes, then doubles back to the last unvisited node and repeats the process. Does not guarantee the shortest path

<br>

## What Else?

- **Mazes** - Check out the different Maze options! Recursive Division Maze randomly divides the grid into segments until it can no longer be divided further - my favorite maze generator!
- **Detour Node** - Adding this node to the grid introduces a new node that must be visited before the path can find the Finish node. Add the Detour and see the different segments of the search!
- **Draggable Nodes** - Drag the Start, Finish, and Detour nodes to move them before animating, or to instantly see new paths after the first was visualized!
- **Overlapped Shortest-Path** - When solving for the shortest path and a Detour node is involved, it is often fastest to double back along the same route. This will make sure you can visualize when that happens!

<br>

## Acknowledgements

This project was inspired by Clement Mihailescu's Pathfinding Visualizer project, which amazed me at the time and made me wonder how the algorithms, animations, and dynamic elements of the application all worked together. I got started with the help of his tutorial from YouTube linked [Here](https://www.youtube.com/watch?v=msttfIHHkak) 


<br>
<br>

---
## Note, everything after this point was auto-generated by Create React App
---

## Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

### Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.